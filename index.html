<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PA Weather Watches & Warnings</title>

  <style>
    table {
      border-collapse: collapse;
      width: 100%;
      max-width: 1200px;
    }

    th, td {
      padding: 6px;
      border: 1px solid #333;
      vertical-align: top;
    }

    th {
      background: #f0f0f0;
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 6px;
    }

    .refresh-label {
      font-size: 0.95em;
      color: #333;
    }

    .type-cell {
      font-weight: 600;
      color: #111;
    }

    .type-watch {
      background-color: rgba(255, 165, 0, 0.5);
    }

    .type-warning {
      background-color: rgba(220, 38, 38, 0.5);
    }

    .section-title {
      margin-top: 16px;
      margin-bottom: 6px;
    }

    .link-btn {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <h1>PA Weather Watches & Warnings</h1>

  <div class="controls">
    <span class="refresh-label">Auto-refresh: every 5 minutes</span>
    <button id="refreshBtn">Refresh Now</button>
  </div>

  <p id="status">Loading alerts…</p>

  <h2 class="section-title">Summary</h2>
  <div id="tableContainer"></div>

  <h2 class="section-title">Alert Links</h2>
  <div id="linksContainer"></div>

  <h2 style="margin-top: 18px;">Alert Map</h2>
  <img
    id="wwaMap"
    src="https://www.weather.gov/images/crh/noc/wwa_pa.png"
    alt="NWS Current Watches, Warnings, and Advisories (PA)"
    style="max-width: 1200px; width: 100%; height: auto; border: 1px solid #ccc;"
  />
  <p style="margin-top: 6px; font-size: 0.95em;">
    Map source:
    <a href="https://www.weather.gov/images/crh/noc/wwa_pa.png" target="_blank" rel="noopener noreferrer">
      NWS Current Watches, Warnings, and Advisories (PA)
    </a>
  </p>

  <script>
    const API_URL = "https://api.weather.gov/alerts/active?area=PA";
    const MAP_URL = "https://www.weather.gov/images/crh/noc/wwa_pa.png";
    const zoneCache = new Map();

    function formatTime(val) {
      if (!val) return "N/A";
      const d = new Date(val);
      return isNaN(d) ? val : d.toLocaleString();
    }

    function isWatchOrWarning(p) {
      const e = (p.event || "").toLowerCase();
      return (
        (e.includes("watch") || e.includes("warning") || e.includes("emergency")) &&
        !e.includes("advisory") &&
        !e.includes("statement") &&
        !e.includes("outlook") &&
        !e.includes("test")
      );
    }

    function getExpiresMs(p) {
      const raw = p.ends || p.expires;
      if (!raw) return null;
      const ms = new Date(raw).getTime();
      return isNaN(ms) ? null : ms;
    }

    async function fetchWithTimeout(url, options = {}, timeoutMs = 8000) {
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), timeoutMs);
      try {
        return await fetch(url, { ...options, signal: controller.signal });
      } finally {
        clearTimeout(id);
      }
    }

    async function getZoneInfo(zoneUrl) {
      if (zoneCache.has(zoneUrl)) return zoneCache.get(zoneUrl);
      try {
        const r = await fetchWithTimeout(zoneUrl, { headers: { Accept: "application/geo+json" } }, 5000);
        const d = await r.json();
        const info = { name: d?.properties?.name || zoneUrl, state: d?.properties?.state || null };
        zoneCache.set(zoneUrl, info);
        return info;
      } catch {
        return { name: zoneUrl, state: null };
      }
    }

    async function getPALocationsFromAffectedZones(p) {
      const zones = Array.isArray(p.affectedZones) ? p.affectedZones : [];
      const settled = await Promise.allSettled(zones.map(getZoneInfo));
      const names = settled
        .filter(r => r.status === "fulfilled" && r.value.state === "PA")
        .map(r => r.value.name);
      return { paNames: [...new Set(names)], hasPA: names.length > 0 };
    }

    function locationSortKey(name) {
      return name
        .replace(/^(n|s|e|w|ne|nw|se|sw|north|south|east|west|northern|southern|eastern|western)\b\.?\s+/i, "")
        .toLowerCase();
    }

    function sortLocations(arr) {
      return arr.sort((a, b) => {
        const ka = locationSortKey(a);
        const kb = locationSortKey(b);
        return ka === kb ? a.localeCompare(b) : ka.localeCompare(kb);
      });
    }

    function groupAlerts(list) {
      const map = new Map();
      for (const a of list) {
        const key = `${a.event}||${a.expiresMs}`;
        if (!map.has(key)) {
          map.set(key, { event: a.event, expiresMs: a.expiresMs, locations: new Set() });
        }
        a.paNames.forEach(l => map.get(key).locations.add(l));
      }
      return [...map.values()].sort((a, b) => (a.expiresMs ?? 1e15) - (b.expiresMs ?? 1e15));
    }

    function getTypeClass(event) {
      return event.toLowerCase().includes("watch") ? "type-watch" : "type-warning";
    }

    function renderSummary(grouped) {
      const c = document.getElementById("tableContainer");
      if (!grouped.length) {
        c.innerHTML = "<p>No active watches or warnings for PA.</p>";
        return;
      }
      c.innerHTML = `
        <table>
          <thead>
            <tr><th>Type</th><th>Locations</th><th>Expires</th></tr>
          </thead>
          <tbody>
            ${grouped.map(g => `
              <tr>
                <td class="type-cell ${getTypeClass(g.event)}">${g.event}</td>
                <td>${sortLocations([...g.locations]).join("; ")}</td>
                <td>${formatTime(g.expiresMs)}</td>
              </tr>
            `).join("")}
          </tbody>
        </table>`;
    }

    function renderLinks(paOnly) {
      const c = document.getElementById("linksContainer");
      if (!paOnly.length) {
        c.innerHTML = "<p>No active watches or warnings for PA.</p>";
        return;
      }

      c.innerHTML = `
        <table>
          <thead>
            <tr><th>Type</th><th>Locations</th><th>Link</th></tr>
          </thead>
          <tbody>
            ${paOnly.map(a => `
              <tr>
                <td class="type-cell ${getTypeClass(a.event)}">${a.event}</td>
                <td>${sortLocations([...a.paNames]).join("; ")}</td>
                <td>
                  ${a.link ? `<a class="link-btn" href="${a.link}" target="_blank">View Warning</a>` : "—"}
                </td>
              </tr>
            `).join("")}
          </tbody>
        </table>`;
    }

    function refreshMap() {
      document.getElementById("wwaMap").src = MAP_URL + "?t=" + Date.now();
    }

    async function fetchAlerts() {
      const status = document.getElementById("status");
      status.textContent = "Loading alerts…";

      try {
        const r = await fetchWithTimeout(API_URL, { headers: { Accept: "application/geo+json" } });
        const d = await r.json();

        const ww = (d.features || []).filter(f => f?.properties && isWatchOrWarning(f.properties));

        const settled = await Promise.allSettled(ww.map(async f => {
          const p = f.properties;
          const pa = await getPALocationsFromAffectedZones(p);
          return {
            event: p.event,
            expiresMs: getExpiresMs(p),
            paNames: pa.paNames,
            hasPA: pa.hasPA,
            link: p.web || null   // ✅ HUMAN-READABLE LINK
          };
        }));

        const paOnly = settled.filter(x => x.status === "fulfilled" && x.value.hasPA).map(x => x.value);

        renderSummary(groupAlerts(paOnly));
        renderLinks(paOnly);

        status.textContent = `Last updated: ${new Date().toLocaleString()} | Alerts: ${paOnly.length}`;
        refreshMap();

      } catch {
        status.textContent = "Error loading alerts.";
      }
    }

    document.getElementById("refreshBtn").onclick = fetchAlerts;
    fetchAlerts();
    setInterval(fetchAlerts, 5 * 60 * 1000);
  </script>
</body>
</html>